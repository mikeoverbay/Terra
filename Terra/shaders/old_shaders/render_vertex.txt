// render_vertex.txt
// used to render blended hirez terrain

uniform sampler2D normalMap;
uniform int main_texture;
uniform vec3 cam_position;
uniform float tile_width;

varying vec3 lightVec; 
varying vec3 eyeVec;
varying vec2 texCoord;
varying vec3 norm;
varying float ln;
varying float ln_b;
varying vec4 Vposition;
varying vec3 Vertex;
varying vec4 RGB;
varying vec4 mask;
varying vec4 mask_2;

void main(void)
{ 
vec3 tangent;
// Create the mask. 
float c_scale = 0.8; // trial and error... These are best fit values.
float m_scale = 1.0;
	mask = vec4( c_scale ,c_scale , c_scale, c_scale);
	mask_2 = vec4(1.0 ,1.0 ,1.0 ,1.0);
if (main_texture == 1 )
{
mask.r = m_scale;
mask_2.r = 0.0;
}
if (main_texture == 2 )
{
mask.g = m_scale;
mask_2.g = 0.0;
}
if (main_texture == 3 )
{
mask.b = m_scale;
mask_2.b = 0.0;
}
if (main_texture == 4 )
{
mask.a = m_scale;
mask_2.a = 0.0;
}

	float nx;
	float ny;
	float nz;
	gl_Position = ftransform();		
	gl_TexCoord[0] = -gl_MultiTexCoord0;
	texCoord = gl_MultiTexCoord0.xy/1.001;

norm.zx = ( texture2D(normalMap, -texCoord*.1).gb *2.0-1.0);
norm.y = sqrt(1.0-((norm.x*norm.x)+(norm.z*norm.z))*0.1 );
norm = normalize(norm);
vec3 tn;
tn.z = norm.z;
tn.y = norm.y;
tn.x = -norm.x;
norm = tn;

	vec3 point = vec3(gl_Vertex.xyz);
	Vposition.z = -point.x;//+( (tile_width/2. )*-100. )-50. ;
	Vposition.y = 1.0;
	Vposition.x = point.z;//+( (tile_width/2. )*100. )+50. ;

// This is the cut off distance for bumpping the surface.
ln = distance(point,cam_position);
ln_b = ln;
if (ln<250.0)
{
	ln = 1.0 - ln/250.0;
	}
	else
	{
	ln = 0.0;
}
if (ln_b<300.0)
{
	ln_b = 1.0 - ln_b/300.0;
	}
	else
	{
	ln_b = 0.0;
}

RGB.x = norm.x;
RGB.y = norm.y;
RGB.z = norm.z;
vec3 c1 = cross( norm, vec3(0.0, 0.0, 1.0) ); 
vec3 c2 = cross( norm, vec3(0.0, 1.0, 0.0) ); 


if( length(c1)>length(c2) )
{
	tangent = c1;	
}
else
{
	tangent = c2;	
}
	
	vec3 n = normalize( norm);
	vec3 t = normalize( tangent);
	vec3 b = cross(n, t);
	
	Vertex = vec3(  gl_Vertex);
	vec3 tmpVec = gl_LightSource[0].position.xyz - Vertex;

	lightVec.x = dot(tmpVec, t);
	lightVec.y = dot(tmpVec, b);
	lightVec.z = dot(tmpVec, n);

	tmpVec = -Vertex;
	//tmpVec = cam_position;
	eyeVec.x = dot(tmpVec, t);
	eyeVec.y = dot(tmpVec, b);
	eyeVec.z = dot(tmpVec, n);
}
